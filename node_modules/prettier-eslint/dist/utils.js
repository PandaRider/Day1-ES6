'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOptionsForFormatting = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _templateObject = _taggedTemplateLiteral(['\n            Getting the value from object configuration of ', '.\n            delving into ', ' with path "', '"\n          '], ['\n            Getting the value from object configuration of ', '.\n            delving into ', ' with path "', '"\n          ']),
    _templateObject2 = _taggedTemplateLiteral(['\n            The ', ' rule is using an object configuration\n            of ', ' but prettier-eslint is\n            not currently capable of getting the prettier value\n            based on an object configuration for ', '.\n            Please file an issue (and make a pull request?)\n          '], ['\n            The ', ' rule is using an object configuration\n            of ', ' but prettier-eslint is\n            not currently capable of getting the prettier value\n            based on an object configuration for ', '.\n            Please file an issue (and make a pull request?)\n          ']),
    _templateObject3 = _taggedTemplateLiteral(['\n          The ', ' rule is configured with a\n          non-object value of ', '. Using that value.\n        '], ['\n          The ', ' rule is configured with a\n          non-object value of ', '. Using that value.\n        ']),
    _templateObject4 = _taggedTemplateLiteral(['\n      The ', ' rule is not configured,\n      using default of ', '\n    '], ['\n      The ', ' rule is not configured,\n      using default of ', '\n    ']);

var _commonTags = require('common-tags');

var _dlv = require('dlv');

var _dlv2 = _interopRequireDefault(_dlv);

var _log = require('./log');

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var logger = (0, _log2.default)();

/* eslint import/prefer-default-export:0 */
exports.getOptionsForFormatting = getOptionsForFormatting;


function getOptionsForFormatting(eslintConfig) {
  var prettierOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var eslint = getRelevantESLintConfig(eslintConfig);
  var prettier = getPrettierOptionsFromESLintRules(eslint, prettierOptions);
  return { eslint: eslint, prettier: prettier };
}

function getRelevantESLintConfig(eslintConfig) {
  var rules = eslintConfig.rules;
  // TODO: remove rules that are not fixable for perf
  // this will require we load the config for every rule...
  // not sure that'll be worth the effort
  // but we may be able to maintain a manual list of rules that
  // are definitely not fixable. Which is what we'll do for now...

  var rulesThatWillNeverBeFixable = [
  // TODO add more
  'no-var', 'prefer-const', 'valid-jsdoc', 'global-require', 'no-with'];

  logger.debug('reducing eslint rules down to relevant rules only');
  var relevantRules = Object.keys(rules).reduce(function (rulesAccumulator, ruleName) {
    if (rulesThatWillNeverBeFixable.indexOf(ruleName) === -1) {
      logger.trace('adding to relevant rules:', JSON.stringify(_defineProperty({}, ruleName, rules[ruleName])));
      rulesAccumulator[ruleName] = rules[ruleName];
    } else {
      logger.trace('omitting from relevant rules:', JSON.stringify(_defineProperty({}, ruleName, rules[ruleName])));
    }
    return rulesAccumulator;
  }, {});

  return _extends({
    // defaults
    useEslintrc: false
  }, eslintConfig, {
    // overrides
    rules: relevantRules,
    fix: true,
    globals: [] });
}

/**
 * This accepts an eslintConfig object and converts
 * it to the `prettier` options object
 */
function getPrettierOptionsFromESLintRules(eslintConfig, prettierOptions) {
  var rules = eslintConfig.rules;

  var optionGetters = {
    printWidth: getPrintWidth,
    tabWidth: getTabWidth,
    parser: getParser,
    singleQuote: getSingleQuote,
    trailingComma: getTrailingComma,
    bracketSpacing: getBraketSpacing
  };

  return Object.keys(optionGetters).reduce(function (options, key) {
    var givenOption = prettierOptions[key];
    var optionIsGiven = prettierOptions[key] !== undefined;
    var getter = optionGetters[key];
    options[key] = optionIsGiven ? givenOption : getter(rules);
    return options;
  }, {});
}

function getPrintWidth(rules) {
  return getRuleValue(rules, 'max-len', 80, 'code');
}

function getTabWidth(rules) {
  var value = getRuleValue(rules, 'indent', 2);
  // if the value is not a number, default to 2
  // use-case is 'tab' where prettier doesn't
  // allow tabs.
  return typeof value === 'number' ? value : 2;
}

function getSingleQuote(rules) {
  var value = getRuleValue(rules, 'quotes', 'single');
  return value === 'single';
}

function getTrailingComma(rules) {
  var value = getRuleValue(rules, 'comma-dangle');
  if (typeof value === 'undefined') {
    var actualValue = rules['comma-dangle'];
    if ((typeof actualValue === 'undefined' ? 'undefined' : _typeof(actualValue)) === 'object') {
      return getValFromObjectConfig(actualValue);
    }
  }

  return value === 'never' ? 'none' : 'all';

  function getValFromObjectConfig(eslintValue) {
    var _eslintValue = _slicedToArray(eslintValue, 2),
        _eslintValue$ = _eslintValue[1],
        arrays = _eslintValue$.arrays,
        objects = _eslintValue$.objects,
        functions = _eslintValue$.functions;

    var es5 = [arrays, objects].some(isAlways);
    var fns = isAlways(functions);
    // eslint-disable-next-line no-nested-ternary
    return fns ? 'all' : es5 ? 'es5' : 'none';
  }
}

function getParser() {
  // TODO: handle flow parser config
  return 'babylon';
}

function getBraketSpacing(rules) {
  var value = getRuleValue(rules, 'object-curly-spacing', 'never');
  return value !== 'never';
}

function getRuleValue(rules, name, defaultValue, objPath) {
  var ruleConfig = rules[name];
  if (Array.isArray(ruleConfig)) {
    var _ruleConfig = _slicedToArray(ruleConfig, 2),
        value = _ruleConfig[1];

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      if (objPath) {
        logger.trace((0, _commonTags.oneLine)(_templateObject, name, JSON.stringify(value), objPath));
        return (0, _dlv2.default)(value, objPath, defaultValue);
      } else {
        logger.debug((0, _commonTags.oneLine)(_templateObject2, name, JSON.stringify(value), name));
      }
    } else {
      logger.trace((0, _commonTags.oneLine)(_templateObject3, name, value));
      return value;
    }
  }
  logger.debug((0, _commonTags.oneLine)(_templateObject4, name, defaultValue));
  // no value configured
  return defaultValue;
}

function isAlways(val) {
  return val.indexOf('always') === 0;
}